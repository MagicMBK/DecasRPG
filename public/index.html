<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medieval RPG - Multiplayer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'MedievalSharp', serif; 
            background: linear-gradient(135deg, #2c1810 0%, #1a0f08 100%); 
            color: #f4e4c1; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh; 
        }
        #menu, #lobby, #game-container { 
            display: none; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
        }
        #menu.active, #lobby.active, #game-container.active { display: block; }
        .menu-box { 
            background: linear-gradient(135deg, #3a2415 0%, #2c1810 100%); 
            border: 4px solid #8b6914; 
            border-radius: 10px; 
            padding: 40px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); 
            text-align: center; 
            min-width: 400px; 
        }
        h1 { 
            color: #ffd700; 
            font-size: 48px; 
            margin-bottom: 10px; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8); 
        }
        h2 { 
            color: #ffd700; 
            font-size: 32px; 
            margin-bottom: 20px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); 
        }
        .subtitle { 
            color: #c9a961; 
            font-size: 18px; 
            margin-bottom: 30px; 
        }
        input { 
            width: 100%; 
            padding: 12px; 
            margin: 10px 0; 
            background: #1a0f08; 
            border: 2px solid #8b6914; 
            border-radius: 5px; 
            color: #f4e4c1; 
            font-size: 16px; 
        }
        input:focus { outline: none; border-color: #ffd700; }
        button { 
            width: 100%; 
            padding: 15px; 
            margin: 10px 0; 
            background: linear-gradient(135deg, #8b6914 0%, #6b5010 100%); 
            border: 2px solid #ffd700; 
            border-radius: 5px; 
            color: #f4e4c1; 
            font-size: 18px; 
            font-weight: bold; 
            cursor: pointer; 
            transition: all 0.3s; 
        }
        button:hover { 
            background: linear-gradient(135deg, #ffd700 0%, #8b6914 100%); 
            transform: scale(1.05); 
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4); 
        }
        .room-list { 
            max-height: 300px; 
            overflow-y: auto; 
            margin: 20px 0; 
            background: #1a0f08; 
            border: 2px solid #8b6914; 
            border-radius: 5px; 
            padding: 10px; 
        }
        .room-item { 
            background: #3a2415; 
            border: 2px solid #6b5010; 
            border-radius: 5px; 
            padding: 15px; 
            margin: 10px 0; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .room-info { text-align: left; }
        .room-name { font-size: 20px; color: #ffd700; font-weight: bold; }
        .room-players { font-size: 14px; color: #c9a961; }
        .join-btn { width: auto; padding: 8px 20px; margin: 0; }
        #game-container { text-align: center; }
        #canvas { 
            border: 4px solid #8b6914; 
            border-radius: 5px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8); 
            background: #2d5016; 
            display: block; 
            cursor: crosshair; 
        }
        .game-ui { 
            position: fixed; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            display: flex; 
            gap: 20px; 
            z-index: 1000; 
        }
        .stat-box { 
            background: rgba(42, 24, 16, 0.9); 
            border: 3px solid #8b6914; 
            border-radius: 8px; 
            padding: 10px 20px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.6); 
        }
        .stat-icon { font-size: 24px; }
        .stat-text { color: #f4e4c1; font-size: 18px; font-weight: bold; }
        .controls { 
            position: fixed; 
            bottom: 20px; 
            left: 20px; 
            background: rgba(42, 24, 16, 0.9); 
            border: 3px solid #8b6914; 
            border-radius: 8px; 
            padding: 15px 20px; 
            color: #c9a961; 
            font-size: 14px; 
            max-width: 350px; 
            z-index: 1000; 
        }
        .player-list { 
            position: fixed; 
            top: 100px; 
            right: 20px; 
            background: rgba(42, 24, 16, 0.9); 
            border: 3px solid #8b6914; 
            border-radius: 8px; 
            padding: 15px; 
            min-width: 200px; 
            max-height: 300px; 
            overflow-y: auto; 
            z-index: 1000; 
        }
        .player-list h3 { 
            color: #ffd700; 
            margin-bottom: 10px; 
            border-bottom: 2px solid #8b6914; 
            padding-bottom: 5px; 
        }
        .player-entry { padding: 5px; color: #f4e4c1; font-size: 14px; }
        #leave-room { 
            position: fixed; 
            top: 20px; 
            left: 20px; 
            width: auto; 
            padding: 10px 20px; 
            z-index: 1000; 
        }
    </style>
</head>
<body>
    <div id="menu" class="active">
        <div class="menu-box">
            <h1>‚öîÔ∏è MEDIEVAL QUEST ‚öîÔ∏è</h1>
            <p class="subtitle">A Multiplayer Adventure</p>
            <input type="text" id="player-name" placeholder="Enter your knight's name" maxlength="15">
            <button onclick="showLobby()">Enter the Realm</button>
        </div>
    </div>
    <div id="lobby">
        <div class="menu-box">
            <h2>üè∞ Game Lobby</h2>
            <input type="text" id="room-name" placeholder="Create a new room name" maxlength="20">
            <button onclick="createRoom()">Create Room</button>
            <div class="room-list" id="room-list">
                <p style="color: #c9a961; text-align: center;">No rooms available. Create one!</p>
            </div>
            <button onclick="refreshRooms()" style="background: #3a2415;">Refresh Rooms</button>
        </div>
    </div>
    <div id="game-container">
        <button id="leave-room" onclick="leaveRoom()">Leave Room</button>
        <div class="game-ui">
            <div class="stat-box"><span class="stat-icon">‚ù§Ô∏è</span><span class="stat-text" id="health">100</span></div>
            <div class="stat-box"><span class="stat-icon">‚öîÔ∏è</span><span class="stat-text" id="score">0</span></div>
            <div class="stat-box"><span class="stat-icon">üëπ</span><span class="stat-text" id="enemies">0</span></div>
        </div>
        <div class="player-list"><h3>Knights Online</h3><div id="players-online"></div></div>
        <canvas id="canvas"></canvas>
        <div class="controls"><strong>Controls:</strong><br>WASD/Arrows: Move<br>SPACE: Melee Attack<br>E/Click: Bow Attack (aim with mouse)<br>Q: Defend (blocks damage)</div>
    </div>
    
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // ====== Networking & State ======
        const socket = io();
        let playerId = null, playerName = '', currentRoom = null;
        let gameState = { players: {}, enemies: [], obstacles: [], arrows: [], myPlayer: null };

        // Track display positions by entity ID to prevent flickering
        let enemyDisplayPositions = new Map(); // id -> {displayX, displayY}
        let arrowDisplayPositions = new Map(); // id -> {displayX, displayY, displayAngle}

        // particles are entirely client-side
        let particles = [], mouseX = 0, mouseY = 0, worldMouseX = 0, worldMouseY = 0;
        let knightImage = new Image();
        knightImage.src = '/knight.png';
        knightImage.onerror = () => console.log('Knight image not found, using fallback rendering');

        // canvas and input
        const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d'), keys = {};
        const world = { width: 3000, height: 2500 };
        let camera = { x: 0, y: 0 };
        
        // Track attack particle creation per player
        let attackParticlesCreated = {};

        function resizeCanvas() { 
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight; 
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function showLobby() { 
            const name = document.getElementById('player-name').value.trim(); 
            if (!name) { 
                alert('Please enter your name!'); 
                return; 
            } 
            playerName = name; 
            socket.emit('setPlayerName', name); 
            document.getElementById('menu').classList.remove('active'); 
            document.getElementById('lobby').classList.add('active'); 
            refreshRooms(); 
        }
        
        function createRoom() { 
            const roomName = document.getElementById('room-name').value.trim(); 
            if (!roomName) { 
                alert('Please enter a room name!'); 
                return; 
            } 
            socket.emit('createRoom', roomName); 
        }
        
        socket.on('roomCreated', () => setTimeout(() => refreshRooms(), 300));
        
        function joinRoom(roomId) { 
            socket.emit('joinRoom', roomId); 
        }
        
        function leaveRoom() { 
            socket.emit('leaveRoom'); 
            currentRoom = null;
            gameState = { players: {}, enemies: [], obstacles: [], arrows: [], myPlayer: null };
            attackParticlesCreated = {};
            particles = [];
            enemyDisplayPositions.clear();
            arrowDisplayPositions.clear();
            document.getElementById('game-container').classList.remove('active'); 
            document.getElementById('lobby').classList.add('active'); 
            refreshRooms(); 
        }
        
        function refreshRooms() { 
            socket.emit('getRooms'); 
        }

        socket.on('connect', () => playerId = socket.id);

        socket.on('roomsList', (rooms) => {
    const roomList = document.getElementById('room-list');
    if (rooms.length === 0) { 
        roomList.innerHTML = '<p style="color: #c9a961; text-align: center;">No rooms available. Create one!</p>'; 
        return; 
    }
    roomList.innerHTML = '';
    rooms.forEach(room => {
        const roomDiv = document.createElement('div');
        roomDiv.className = 'room-item';
        roomDiv.innerHTML = `
            <div class="room-info">
                <div class="room-name">üè∞ ${room.name}</div>
                <div class="room-players">üë• ${room.players} / 8 players</div>
            </div>
            <div>
                <button class="join-btn" onclick="joinRoom('${room.id}')" ${room.players >= 8 ? 'disabled' : ''}>
                    ${room.players >= 8 ? 'Full' : 'Join'}
                </button>
                <button class="join-btn" onclick="deleteRoom('${room.id}')">Delete</button>
            </div>
        `;
        roomList.appendChild(roomDiv);
    });
    });

        socket.on('roomJoined', (room) => { 
            currentRoom = room; 
            attackParticlesCreated = {};
            particles = [];
            enemyDisplayPositions.clear();
            arrowDisplayPositions.clear();
            document.getElementById('lobby').classList.remove('active'); 
            document.getElementById('game-container').classList.add('active'); 
            startGame(); 
        });

        socket.on('error', (msg) => {
            alert(msg);
        });

        // ====== State updates from server ======
        socket.on('gameState', (state) => {
            if (!state) return;
            
            // Preserve existing display positions before updating
            const oldPlayers = gameState.players || {};
            
            gameState = state;
            
            // Initialize or preserve display positions for players (by ID)
            for (const id in gameState.players) {
                const p = gameState.players[id];
                const oldPlayer = oldPlayers[id];
                if (oldPlayer && oldPlayer.displayX !== undefined) {
                    // Preserve existing display position
                    p.displayX = oldPlayer.displayX;
                    p.displayY = oldPlayer.displayY;
                } else {
                    // Initialize new player
                    p.displayX = p.x;
                    p.displayY = p.y;
                }
            }
            
            // Initialize display positions for enemies (by ID using Map)
            gameState.enemies.forEach(e => {
                if (!enemyDisplayPositions.has(e.id)) {
                    // New enemy - initialize at actual position
                    enemyDisplayPositions.set(e.id, { displayX: e.x, displayY: e.y });
                }
                // Copy display position from map to entity
                const displayPos = enemyDisplayPositions.get(e.id);
                e.displayX = displayPos.displayX;
                e.displayY = displayPos.displayY;
            });
            
            // Clean up display positions for enemies that no longer exist
            const currentEnemyIds = new Set(gameState.enemies.map(e => e.id));
            for (const id of enemyDisplayPositions.keys()) {
                if (!currentEnemyIds.has(id)) {
                    enemyDisplayPositions.delete(id);
                }
            }
            
            // Initialize display positions for arrows (by ID using Map)
            gameState.arrows.forEach(a => {
                if (!arrowDisplayPositions.has(a.id)) {
                    // New arrow - initialize at actual position
                    arrowDisplayPositions.set(a.id, { 
                        displayX: a.x, 
                        displayY: a.y,
                        displayAngle: Math.atan2(a.vy || 0, a.vx || 0)
                    });
                }
                // Copy display position from map to entity
                const displayPos = arrowDisplayPositions.get(a.id);
                a.displayX = displayPos.displayX;
                a.displayY = displayPos.displayY;
                a.displayAngle = displayPos.displayAngle;
            });
            
            // Clean up display positions for arrows that no longer exist
            const currentArrowIds = new Set(gameState.arrows.map(a => a.id));
            for (const id of arrowDisplayPositions.keys()) {
                if (!currentArrowIds.has(id)) {
                    arrowDisplayPositions.delete(id);
                }
            }

            gameState.myPlayer = gameState.players[playerId];

            // Update UI
            if (gameState.myPlayer) { 
                document.getElementById('health').textContent = Math.floor(gameState.myPlayer.health); 
                document.getElementById('score').textContent = gameState.myPlayer.score; 
            }
            document.getElementById('enemies').textContent = (gameState.enemies || []).length;
            
            const playersOnline = document.getElementById('players-online'); 
            playersOnline.innerHTML = '';
            Object.values(gameState.players).forEach(player => {
                const entry = document.createElement('div'); 
                entry.className = 'player-entry';
                const healthColor = player.health > 50 ? '#4ade80' : player.health > 25 ? '#fbbf24' : '#ef4444';
                entry.innerHTML = `<span style="color: ${healthColor}">‚ù§Ô∏è ${Math.floor(player.health)}</span> ${player.name}`;
                playersOnline.appendChild(entry);
            });
        });

        // Particle / effect events
        socket.on('enemyHit', (data) => createHitEffect(data.x, data.y, '#ff0000'));
        socket.on('playerDied', (data) => {
            if (data.playerId === playerId) { 
                const player = gameState.players[playerId];
                if (player) createDeathEffect(player.displayX + player.size/2, player.displayY + player.size/2);
                setTimeout(() => alert(`You were slain! Score: ${data.score}`), 500); 
            } else { 
                const player = gameState.players[data.playerId]; 
                if (player) createDeathEffect(player.displayX + player.size/2, player.displayY + player.size/2);
            }
        });

        // ===== Particle system =====
        function createHitEffect(x, y, color) { 
            for (let i = 0; i < 15; i++) 
                particles.push({ 
                    x, y, 
                    vx: (Math.random() - 0.5) * 200, 
                    vy: (Math.random() - 0.5) * 200, 
                    life: 0.5 + Math.random() * 0.6, 
                    maxLife: 0.5 + Math.random() * 0.6, 
                    color, 
                    size: Math.random() * 4 + 2 
                }); 
        }
        
        function createDeathEffect(x, y) { 
            for (let i = 0; i < 50; i++) 
                particles.push({ 
                    x, y, 
                    vx: (Math.random() - 0.5) * 400, 
                    vy: (Math.random() - 0.5) * 400, 
                    life: 1 + Math.random() * 1.2, 
                    maxLife: 1 + Math.random() * 1.2, 
                    color: Math.random() > 0.5 ? '#8b0000' : '#ff0000', 
                    size: Math.random() * 6 + 3 
                }); 
        }
        
        function createAttackEffect(x, y) { 
            for (let i = 0; i < 10; i++) 
                particles.push({ 
                    x, y, 
                    vx: (Math.random() - 0.5) * 150, 
                    vy: (Math.random() - 0.5) * 150, 
                    life: 0.4 + Math.random() * 0.4, 
                    maxLife: 0.4 + Math.random() * 0.4, 
                    color: '#ffd700', 
                    size: Math.random() * 3 + 1 
                }); 
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 500 * dt; // gravity
                p.life -= dt;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // ===== Rendering / smoothing =====
        let lastTime = performance.now();
        function startGame() { 
            lastTime = performance.now(); 
            requestAnimationFrame(gameLoop); 
        }

        function lerp(a, b, t) { return a + (b - a) * t; }

        function clampCameraToWorld() {
            camera.x = Math.max(0, Math.min(world.width - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(world.height - canvas.height, camera.y));
        }

        function gameLoop(timestamp) {
            const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
            lastTime = timestamp;

            if (!document.getElementById('game-container').classList.contains('active')) return;

            // Send input to server
            socket.emit('playerInput', { 
                keys, 
                room: currentRoom, 
                mouseX: worldMouseX, 
                mouseY: worldMouseY 
            });

            updateParticles(dt);
            
            // Smooth interpolation
            const smoothingFactor = 1 - Math.exp(-12 * dt);

            // Smooth players
            Object.values(gameState.players).forEach(p => {
                p.displayX = lerp(p.displayX, p.x, smoothingFactor);
                p.displayY = lerp(p.displayY, p.y, smoothingFactor);
            });
            
            // Smooth enemies (update the Map, then copy back to entity)
            gameState.enemies.forEach(e => {
                const displayPos = enemyDisplayPositions.get(e.id);
                if (displayPos) {
                    displayPos.displayX = lerp(displayPos.displayX, e.x, smoothingFactor);
                    displayPos.displayY = lerp(displayPos.displayY, e.y, smoothingFactor);
                    e.displayX = displayPos.displayX;
                    e.displayY = displayPos.displayY;
                }
            });
            
            // Smooth arrows (update the Map, then copy back to entity)
            gameState.arrows.forEach(a => {
                const displayPos = arrowDisplayPositions.get(a.id);
                if (displayPos) {
                    displayPos.displayX = lerp(displayPos.displayX, a.x, smoothingFactor);
                    displayPos.displayY = lerp(displayPos.displayY, a.y, smoothingFactor);
                    const targetAngle = Math.atan2(a.vy || 0, a.vx || 0);
                    displayPos.displayAngle = lerp(displayPos.displayAngle, targetAngle, smoothingFactor);
                    a.displayX = displayPos.displayX;
                    a.displayY = displayPos.displayY;
                    a.displayAngle = displayPos.displayAngle;
                }
            });

            // Camera follows player smoothly
            if (gameState.myPlayer) {
                const p = gameState.myPlayer;
                const targetX = p.displayX + p.size / 2 - canvas.width / 2;
                const targetY = p.displayY + p.size / 2 - canvas.height / 2;
                camera.x = lerp(camera.x, targetX, 1 - Math.exp(-8 * dt));
                camera.y = lerp(camera.y, targetY, 1 - Math.exp(-8 * dt));
                clampCameraToWorld();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#4a5c3a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Grid
            ctx.strokeStyle = '#3a4c2a'; 
            ctx.lineWidth = 2;
            const startX = Math.floor(camera.x / 50) * 50;
            const startY = Math.floor(camera.y / 50) * 50;
            const endX = camera.x + canvas.width;
            const endY = camera.y + canvas.height;
            for (let x = startX; x < endX + 50; x += 50) {
                for (let y = startY; y < endY + 50; y += 50) {
                    ctx.strokeRect(x, y, 50, 50);
                }
            }

            // Obstacles
            gameState.obstacles.forEach(obs => {
                let color1, color2, strokeColor;
                if (obs.type === 'tower') { 
                    color1 = '#5a5a5a'; 
                    color2 = '#4a4a4a'; 
                    strokeColor = '#2a2a2a'; 
                } else if (obs.type === 'wood') { 
                    color1 = '#8b4513'; 
                    color2 = '#654321'; 
                    strokeColor = '#3d2817'; 
                } else if (obs.type === 'wall') { 
                    color1 = '#808080'; 
                    color2 = '#696969'; 
                    strokeColor = '#404040'; 
                } else { 
                    color1 = '#6a6a6a'; 
                    color2 = '#555555'; 
                    strokeColor = '#333333'; 
                }
                
                ctx.fillStyle = color1; 
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                
                // Brick pattern
                ctx.fillStyle = color2; 
                const brickHeight = 20, brickWidth = 40;
                for (let y = 0; y < obs.height; y += brickHeight) {
                    const offset = ((y / brickHeight) % 2) * (brickWidth / 2);
                    for (let x = 0; x < obs.width; x += brickWidth) { 
                        ctx.strokeStyle = strokeColor; 
                        ctx.lineWidth = 2; 
                        ctx.strokeRect(obs.x + x + offset, obs.y + y, brickWidth, brickHeight); 
                    }
                }
                
                ctx.strokeStyle = strokeColor; 
                ctx.lineWidth = 4; 
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
            });

            // Enemies
            gameState.enemies.forEach(enemy => {
                const ex = enemy.displayX, ey = enemy.displayY;
                ctx.fillStyle = '#8b0000'; 
                ctx.beginPath(); 
                ctx.arc(ex + enemy.size/2, ey + enemy.size/2, enemy.size/2, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.strokeStyle = '#4a0000'; 
                ctx.lineWidth = 2; 
                ctx.stroke();
                
                // Eyes
                ctx.fillStyle = '#ff0000'; 
                ctx.beginPath(); 
                ctx.arc(ex + enemy.size/2 - 5, ey + enemy.size/2 - 3, 3, 0, Math.PI * 2); 
                ctx.arc(ex + enemy.size/2 + 5, ey + enemy.size/2 - 3, 3, 0, Math.PI * 2); 
                ctx.fill();
                
                // Health bar
                const barWidth = enemy.size; 
                ctx.fillStyle = '#000'; 
                ctx.fillRect(ex, ey - 10, barWidth, 5); 
                ctx.fillStyle = '#ff0000'; 
                ctx.fillRect(ex, ey - 10, barWidth * (enemy.health / enemy.maxHealth), 5);
            });

            // Other players
            Object.values(gameState.players).forEach(player => {
                if (player.id === playerId) return;
                drawPlayer(player);
            });

            // My player (draw last so it's on top)
            if (gameState.myPlayer) {
                drawPlayer(gameState.myPlayer, true);
            }

            // Arrows
            gameState.arrows.forEach(arrow => {
                ctx.save();
                ctx.translate(arrow.displayX, arrow.displayY);
                ctx.rotate(arrow.displayAngle || 0);
                ctx.fillStyle = '#8b4513'; 
                ctx.fillRect(-10, -2, 20, 4);
                ctx.fillStyle = '#c0c0c0'; 
                ctx.beginPath(); 
                ctx.moveTo(10, 0); 
                ctx.lineTo(5, -4); 
                ctx.lineTo(5, 4); 
                ctx.closePath(); 
                ctx.fill();
                ctx.fillStyle = '#ff0000'; 
                ctx.fillRect(-12, -3, 4, 2); 
                ctx.fillRect(-12, 1, 4, 2);
                ctx.restore();
            });

            // Particles
            drawParticles();

            ctx.restore();

            drawMinimap();
        }

        function drawPlayer(player, isMyPlayer = false) {
            const px = player.displayX, py = player.displayY;
            
            // Defend shield effect
            if (player.defending) {
                ctx.save(); 
                ctx.globalAlpha = 0.6; 
                ctx.fillStyle = '#4169e1'; 
                ctx.strokeStyle = '#1e90ff'; 
                ctx.lineWidth = isMyPlayer ? 4 : 3; 
                ctx.beginPath(); 
                ctx.arc(px + player.size/2, py + player.size/2, player.size * 0.9, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.stroke();
                
                if (isMyPlayer) {
                    const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8; 
                    ctx.globalAlpha = pulse * 0.4; 
                    ctx.strokeStyle = '#87ceeb'; 
                    ctx.lineWidth = 6; 
                    ctx.beginPath(); 
                    ctx.arc(px + player.size/2, py + player.size/2, player.size * 1.1, 0, Math.PI * 2); 
                    ctx.stroke();
                }
                ctx.restore();
            }
            
            // Player sprite
            if (knightImage.complete && knightImage.naturalWidth > 0) { 
                ctx.drawImage(knightImage, px, py, player.size, player.size); 
            } else {
                // Fallback rendering
                ctx.fillStyle = '#c0c0c0'; 
                ctx.beginPath(); 
                ctx.arc(px + player.size/2, py + player.size/2, player.size/2, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.strokeStyle = '#2c1810'; 
                ctx.lineWidth = isMyPlayer ? 3 : 2; 
                ctx.stroke(); 
                ctx.fillStyle = player.color; 
                ctx.fillRect(px + player.size/2 - 5, py + 5, 10, 15); 
                ctx.fillStyle = '#ffd700'; 
                ctx.beginPath(); 
                ctx.arc(px + player.size/2, py + player.size/2 + 5, player.size/4, 0, Math.PI * 2); 
                ctx.fill();
            }
            
            // Attack animation
            if (player.attacking) {
                ctx.strokeStyle = '#ffd700'; 
                ctx.lineWidth = isMyPlayer ? 4 : 3; 
                ctx.beginPath(); 
                ctx.arc(px + player.size/2, py + player.size/2, 60, 0, Math.PI * 2); 
                ctx.stroke();
                
                if (isMyPlayer) {
                    ctx.strokeStyle = '#c0c0c0'; 
                    ctx.lineWidth = 3; 
                    ctx.beginPath(); 
                    const angle = (Date.now() / 50) % (Math.PI * 2);
                    const slashX = Math.cos(angle) * 50;
                    const slashY = Math.sin(angle) * 50; 
                    ctx.moveTo(px + player.size/2, py + player.size/2); 
                    ctx.lineTo(px + player.size/2 + slashX, py + player.size/2 + slashY); 
                    ctx.stroke();
                }
                
                // Create attack particles once per attack
                if (!attackParticlesCreated[player.id]) {
                    createAttackEffect(px + player.size/2, py + player.size/2);
                    attackParticlesCreated[player.id] = true;
                }
            } else {
                attackParticlesCreated[player.id] = false;
            }
            
            // Player name
            ctx.fillStyle = isMyPlayer ? '#ffd700' : '#fff'; 
            ctx.font = isMyPlayer ? 'bold 16px Arial' : 'bold 14px Arial'; 
            ctx.textAlign = 'center'; 
            ctx.strokeStyle = '#000'; 
            ctx.lineWidth = isMyPlayer ? 4 : 3; 
            ctx.strokeText(player.name, px + player.size/2, py - 10); 
            ctx.fillText(player.name, px + player.size/2, py - 10);
        }

        function drawMinimap() {
            const minimapSize = 180;
            const minimapX = canvas.width - minimapSize - 20;
            const minimapY = canvas.height - minimapSize - 80;
            const worldWidth = world.width, worldHeight = world.height;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
            ctx.fillRect(minimapX, minimapY, minimapSize, minimapSize * (worldHeight / worldWidth));
            ctx.strokeStyle = '#8b6914'; 
            ctx.lineWidth = 3; 
            ctx.strokeRect(minimapX, minimapY, minimapSize, minimapSize * (worldHeight / worldWidth));
            
            const scaleX = minimapSize / worldWidth;
            const scaleY = (minimapSize * (worldHeight / worldWidth)) / worldHeight;
            
            // Obstacles
            gameState.obstacles.forEach(obs => { 
                if (obs.type === 'tower') ctx.fillStyle = '#444'; 
                else if (obs.type === 'wood') ctx.fillStyle = '#8b4513'; 
                else ctx.fillStyle = '#666'; 
                ctx.fillRect(minimapX + obs.x * scaleX, minimapY + obs.y * scaleY, Math.max(2, obs.width * scaleX), Math.max(2, obs.height * scaleY)); 
            });
            
            // Enemies
            ctx.fillStyle = '#ff4444'; 
            gameState.enemies.forEach(enemy => { 
                ctx.beginPath(); 
                ctx.arc(minimapX + (enemy.displayX + enemy.size/2) * scaleX, minimapY + (enemy.displayY + enemy.size/2) * scaleY, 2, 0, Math.PI * 2); 
                ctx.fill(); 
            });
            
            // Other players
            Object.values(gameState.players).forEach(player => { 
                if (player.id === playerId) return; 
                ctx.fillStyle = '#ffff00'; 
                ctx.beginPath(); 
                ctx.arc(minimapX + (player.displayX + player.size/2) * scaleX, minimapY + (player.displayY + player.size/2) * scaleY, 3, 0, Math.PI * 2); 
                ctx.fill(); 
            });
            
            // My player
            if (gameState.myPlayer) { 
                ctx.fillStyle = '#00ff00'; 
                ctx.beginPath(); 
                ctx.arc(minimapX + (gameState.myPlayer.displayX + gameState.myPlayer.size/2) * scaleX, minimapY + (gameState.myPlayer.displayY + gameState.myPlayer.size/2) * scaleY, 4, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.strokeStyle = '#fff'; 
                ctx.lineWidth = 1; 
                ctx.stroke(); 
            }
        }

        // ===== Input handling =====
        window.addEventListener('keydown', (e) => { 
            if (e.target.tagName === 'INPUT') return; 
            keys[e.key.toLowerCase()] = true; 
            if (['w','a','s','d',' ','q','e','arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())) {
                e.preventDefault(); 
            }
        });
        
        window.addEventListener('keyup', (e) => { 
            if (e.target.tagName === 'INPUT') return; 
            keys[e.key.toLowerCase()] = false; 
        });

        canvas.addEventListener('mousemove', (e) => { 
            const rect = canvas.getBoundingClientRect(); 
            mouseX = e.clientX - rect.left; 
            mouseY = e.clientY - rect.top; 
            worldMouseX = mouseX + camera.x; 
            worldMouseY = mouseY + camera.y; 
        });
        
        // Mouse click triggers bow attack
        canvas.addEventListener('click', () => {
            keys['e'] = true;
            setTimeout(() => { keys['e'] = false; }, 50);
        });

    </script>
</body>
</html>